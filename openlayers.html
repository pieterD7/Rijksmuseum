<!DOCTYPE html>
<html>
    <head>
    <title>Voorzijde.png</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv='imagetoolbar' content='no'/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style type="text/css">
        html, body { overflow: hidden; padding: 0; height: 100%; font-family: 'Lucida Grande',Geneva,Arial,Verdana,sans-serif; }
        body { margin: 10px; background: #fff; }
        h1, h4 { margin: 0; padding: 6px; border:0; font-size: 20pt; }
        #header { height: 43px; padding: 0; background-color: #eee; border: 1px solid #888; }
        #subheader { height: 12px; text-align: right; font-size: 10px; color: #555;}
        #map { overflow: visible; position: relative; height: 100%; border: 1px solid #888; }
        .info-box {
            pointer-events: none;
            max-width: 32em;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border: 2px solid #888;
            border-radius: 8px; 
        }
        /* Mobile-first approach */
        .container {
            #header {
                display: none;
            }   
        }

        /* Tablet breakpoint (approx 768px) */
        @media (min-width: 48em) {
            #header {
                display: none;
            }
        }

        /* Desktop breakpoint (approx 1024px) */
        @media (min-width: 64em) {
            #header {
                display: block;
            }
            .info-box {
                max-width: calc(100vw - 32em);  
            }
        }

    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.0.0/legacy/ol.css" type="text/css">
    <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.0.0/legacy/ol.js"></script>
    <script src="https://unpkg.com/ol-layerswitcher@4.1.1"></script>
    <link rel="stylesheet" href="https://unpkg.com/ol-layerswitcher@4.1.1/src/ol-layerswitcher.css" />
</head>
<body>
    <div id="header"><h1>Voorzijde.png</h1></div>
    <div id="subheader">Generated by <a href="https://gdal.org/programs/gdal2tiles.html">GDAL2Tiles</a>&nbsp;&nbsp;&nbsp;&nbsp;</div>
    <div id="map" class="map"></div>
    <div id="info" class="info-box"></div>
    <script type="text/javascript">

        function coordinateToPixel(coord, view, mapSize) {
            const resolution = view.getResolution();
            const center = view.getCenter();

            return [
                (coord[0] - center[0]) / resolution + mapSize[0] / 2,
                (center[1] - coord[1]) / resolution + mapSize[1] / 2
            ];
        }

        function openFullscreen() {
            const elem = document.getElementById("map");

            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } 
        }
        function normalizeExtent(ext) {
            const [x1, y1, x2, y2] = ext;
            return [
                Math.min(x1, x2),
                Math.min(y1, y2),
                Math.max(x1, x2),
                Math.max(y1, y2)
            ];
        }

        var mousePositionControl = new ol.control.MousePosition({
            className: 'custom-mouse-position',
            target: document.getElementById('mouse-position'),
            undefinedHTML: '&nbsp;'
        });
        var map = new ol.Map({
            controls: ol.control.defaults.defaults().extend([new ol.control.FullScreen()]),
            target: 'map',
            layers: [
                new ol.layer.Group({
                    title: 'Overlay',
                    layers: [
                        new ol.layer.Tile({
                            title: 'Overlay',
                            // opacity: 0.7,
                            source: new ol.source.TileImage({
                                attributions: '',
                                tileGrid: new ol.tilegrid.TileGrid({
                                    extent: [0,-7724,16384,0],
                                    origin: [0,-7724],
                                    resolutions: [64,32,16,8,4,2,1,0.5],
                                    tileSize: [256, 256]
                                }),
                                tileUrlFunction: function(tileCoord) {
                                    return ('./{z}/{x}/{y}.png'
                                        .replace('{z}', String(tileCoord[0]))
                                        .replace('{x}', String(tileCoord[1]))
                                        .replace('{y}', String(- 1 - tileCoord[2])));
                                },
                            })
                        }),
                    ]
                }),
            ],
            view: new ol.View({
                center: [8192, -3862],
                zoom: 1,
                constrainResolution: true,
                resolutions: [64,32,16,8,4,2,1,0.5],
                extent: [0,-7724,16384,0]
            })
        });

        map.getInteractions().forEach(interaction => {
        if (interaction instanceof ol.interaction.DragRotate ||
            interaction instanceof ol.interaction.PinchZoom ||
            interaction instanceof ol.interaction.PinchRotate) {
            map.removeInteraction(interaction);
        }
        });

        var infoConfig = null
        fetch('./info-config.json')
        .then(res => res.json())
        .then(json => {
            infoConfig = json;
            updateInfo();
        });

        const vectorSource = new ol.source.Vector();

        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            geometryFunction: ol.interaction.Draw.createBox(),
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: '#E0E9F6',
                    width: 3
                }),
                fill: null
            })
        });

        const infoDiv = document.getElementById('info');

        function extentCenter(ext) {
            return [
                (ext[0] + ext[2]) / 2,
                (ext[1] + ext[3]) / 2
            ];
        }

        function extentMidpoint(ext) {
            return [
                (ext[0] + ext[2]) / 2,
                (ext[1] + ext[3]) / 2
            ];
        }

        function closestMidpointOnExtent(ext, point) {
            const [minX, minY, maxX, maxY] = ext;
            const [px, py] = point;

            // 1️⃣ punt ligt binnen extent → midden extent
            if (
                px >= minX && px <= maxX &&
                py >= minY && py <= maxY
            ) {
                return extentMidpoint(ext);
            }

            // 2️⃣ bepaal dichtstbijzijnde zijde
            const dx = px < minX ? minX - px : px > maxX ? px - maxX : 0;
            const dy = py < minY ? minY - py : py > maxY ? py - maxY : 0;

            // horizontaal verder weg → linker/rechter zijde
            if (dx > dy) {
                return [
                px < minX ? minX : maxX,
                (minY + maxY) / 2
                ];
            }

            // verticaal verder weg → boven/onder zijde
            return [
                (minX + maxX) / 2,
                py < minY ? minY : maxY
            ];
        }

        function closestPointOnExtent(ext, point) {
            const [x, y] = point;

            return [
                Math.min(Math.max(x, ext[0]), ext[2]),
                Math.min(Math.max(y, ext[1]), ext[3])
            ];
        }

        function distanceSq(a, b) {
            const dx = a[0] - b[0];
            const dy = a[1] - b[1];
            return dx * dx + dy * dy;
        }
        function findNearestExtent(items, mapCenter) {
            let bestItem = null;
            let bestDistance = Infinity;

            items.forEach(item => {
                if (!item.extent) return;

                const ext = normalizeExtent(item.extent);

                const closest = closestMidpointOnExtent(ext, mapCenter);
                const d = distanceSq(mapCenter, closest);

                if (d < bestDistance) {
                    bestDistance = d;
                    bestItem = item;
                }
            });

            return bestItem;
        }


        function updateInfo() {
            if (!infoConfig) return;

            const zoom = Math.round(map.getView().getZoom());
            const viewExtent = map.getView().calculateExtent();

            console.log('Zoom:', zoom);
            // console.log('View extent:', viewExtent);

            const matches = infoConfig.items.filter(item => {
                // zoom check
                if (zoom < item.zoom.min || zoom > item.zoom.max) return false;


                if (item.extent) {
                    return ol.extent.intersects(item.extent, viewExtent);
                }

                return true;
            });

            if(matches){
                const center = map.getView().getCenter();
                let match = findNearestExtent(matches, center);

                if(match && match.extent){
                    const rectangle = ol.geom.Polygon.fromExtent(normalizeExtent(match.extent));

                    const feature = new ol.Feature({
                        geometry: rectangle
                    });
                    
                    vectorSource.clear();
                    vectorSource.addFeature(feature);
                    
                    const infoOverlay = new ol.Overlay({
                        autoPan: false,
                        stopEvent: false,
                        element: document.querySelector('.info-box'),
                        positioning: 'top-left',
                        offset: [0, 0],
                    });
                    map.addOverlay(infoOverlay);

                    const coord = rectangle.getCoordinates()[0][0];
                    infoOverlay.setPosition(coord);
                    //infoOverlay.panIntoView();

                    infoDiv.innerHTML = `
                        ${match.title ? `<h4>${match.title}</h4>` : ""}
                        <p>${match.text}</p>`;
                }

            }
            else{
                infoDiv.innerHTML = "";
                return;
            }
        }

        map.addLayer(vectorLayer);

        const draw = new ol.interaction.Draw({
            source: vectorSource,
            type: 'Circle',
            geometryFunction: ol.interaction.Draw.createBox()
        });

        //map.addInteraction(draw);

        map.addControl(new ol.control.ZoomSlider());

        // update bij zoomen
        map.getView().on('change:resolution', updateInfo);
        map.on('moveend', updateInfo);
        
        // initieel
        updateInfo();

        draw.on('drawend', function (event) {
            const feature = event.feature;
            const geometry = feature.getGeometry();

            // extent = [minX, minY, maxX, maxY] in kaartcoördinaten
            const extent = geometry.getExtent();

            console.log('Extent:', extent);
        });

        document.addEventListener('fullscreenchange', updateInfo);

    </script>
</body>
</html>